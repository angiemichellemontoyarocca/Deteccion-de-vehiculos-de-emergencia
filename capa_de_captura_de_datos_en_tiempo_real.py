# -*- coding: utf-8 -*-
"""Capa de captura de datos en tiempo real

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1clOzLAk87fLkriOfMo8gP3lsdPYxh-q2
"""

!pip install opencv-python-headless
!pip install tensorflow
!pip install opencv-python
!pip install ipywidgets

!pip install tensorflow opencv-python numpy

from IPython.display import Javascript, HTML, Image, display as ipython_display
import cv2
import numpy as np
from tensorflow.keras.models import load_model
import base64
import time
from datetime import datetime
from google.colab.output import eval_js
import io
from PIL import Image as PILImage

# Configurar GPU si está disponible
gpus = tf.config.experimental.list_physical_devices('GPU')
if gpus:
    try:
        for gpu in gpus:
            tf.config.experimental.set_memory_growth(gpu, True)
    except RuntimeError as e:
        print(e)

# Configuración global
IMG_SIZE = 160
MODEL_PATH = '/content/drive/MyDrive/Fundamentos CNN/emergency_vehicle_model.keras'
CONFIDENCE_THRESHOLD = 0.7

# Montar Google Drive
drive.mount('/content/drive')

def show_webcam_widget():
    js_code = """
    <div id="webcam-container">
        <video id="webcam" autoplay playsinline width="640" height="480"></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <script>
    var video = document.querySelector("#webcam");
    var canvas = document.querySelector("#canvas");
    var ctx = canvas.getContext('2d');

    navigator.mediaDevices.getUserMedia({video: true})
        .then((stream) => {
            video.srcObject = stream;
            video.play();
        })
        .catch((err) => {
            console.error("Error: " + err);
        });

    function processFrame() {
        if (video.videoWidth > 0) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            window.frameData = canvas.toDataURL('image/jpeg', 0.8);
        }
        requestAnimationFrame(processFrame);
    }

    processFrame();
    </script>
    """
    ipython_display(HTML(js_code))

def js_to_image(js_reply):
    """Convierte la respuesta JS a una imagen numpy"""
    if js_reply is None or ',' not in js_reply:
        return None
    image_bytes = base64.b64decode(js_reply.split(',')[1])
    image = PILImage.open(io.BytesIO(image_bytes))
    image = np.array(image)
    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
    return image

def preprocess_image(image):
    """Preprocesa la imagen para el modelo"""
    # Redimensionar a 160x160
    image_resized = cv2.resize(image, (IMG_SIZE, IMG_SIZE))
    # Convertir a float32 y normalizar
    image_normalized = image_resized.astype(np.float32) / 255.0
    # Expandir dimensiones para el batch
    return np.expand_dims(image_normalized, axis=0)

def draw_prediction(image, prediction):
    """Dibuja las predicciones en la imagen"""
    height, width = image.shape[:2]
    emergency_prob = prediction[0][1]

    if emergency_prob > CONFIDENCE_THRESHOLD:
        # Detectar el objeto principal en la imagen usando diferencia de color
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (5, 5), 0)
        _, thresh = cv2.threshold(blur, 60, 255, cv2.THRESH_BINARY)
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        if contours:
            # Encontrar el contorno más grande (presumiblemente el vehículo)
            largest_contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(largest_contour)

            # Dibujar solo el rectángulo alrededor del vehículo
            color = (0, 0, 255) if emergency_prob > CONFIDENCE_THRESHOLD else (0, 255, 0)
            cv2.rectangle(image, (x, y), (x + w, y + h), color, 2)

            # Agregar etiqueta encima del rectángulo
            label = f"Emergency: {emergency_prob:.2%}" if emergency_prob > CONFIDENCE_THRESHOLD else f"Normal: {1-emergency_prob:.2%}"
            cv2.putText(image, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

    return image

def detect_vehicles(model):
    """Función principal para detección en tiempo real"""
    # Mostrar widget de webcam
    show_webcam_widget()

    # Crear elemento para mostrar resultados
    ipython_display(HTML("""
        <div id="result" style="
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        "></div>
    """))

    print("Iniciando detección en tiempo real...")
    last_detection_time = 0  # Para evitar detecciones múltiples del mismo vehículo
    DETECTION_COOLDOWN = 5  # Tiempo mínimo (en segundos) entre detecciones

    while True:
        try:
            # Obtener frame de la webcam
            frame_data = eval_js('window.frameData')
            if frame_data is None:
                continue

            img = js_to_image(frame_data)
            if img is None:
                continue

            # Preprocesar imagen para el modelo
            img_processed = preprocess_image(img)

            try:
                # Realizar predicción
                prediction = model.predict(img_processed, verbose=0)
                emergency_prob = prediction[0][1]

                current_time = time.time()
                height, width = img.shape[:2]

                if emergency_prob > CONFIDENCE_THRESHOLD:
                    # Vehículo de emergencia detectado
                    color = (0, 0, 255)  # Rojo
                    label = f"Vehículo de Emergencia: {emergency_prob:.2%}"
                    border_thickness = 3

                    # Solo guardar si ha pasado suficiente tiempo desde la última detección
                    if current_time - last_detection_time > DETECTION_COOLDOWN:
                        filename = f'emergency_{datetime.now().strftime("%Y%m%d_%H%M%S")}.jpg'
                        cv2.imwrite(filename, img)
                        print(f"¡Vehículo de emergencia detectado! Imagen guardada como {filename}")
                        last_detection_time = current_time

                else:
                    # Vehículo normal
                    color = (0, 255, 0)  # Verde
                    label = f"Vehículo Normal: {1-emergency_prob:.2%}"
                    border_thickness = 2

                # Dibujar rectángulo y etiqueta
                gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                blur = cv2.GaussianBlur(gray, (5, 5), 0)
                _, thresh = cv2.threshold(blur, 60, 255, cv2.THRESH_BINARY)
                contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

                if contours:
                    # Encontrar el contorno más grande (presumiblemente el vehículo)
                    largest_contour = max(contours, key=cv2.contourArea)
                    x, y, w, h = cv2.boundingRect(largest_contour)

                    # Dibujar solo el rectángulo alrededor del vehículo
                    cv2.rectangle(img, (x, y), (x + w, y + h), color, border_thickness)
                    cv2.putText(img, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

                # Convertir imagen procesada a base64
                _, buffer = cv2.imencode('.jpg', img)
                img_base64 = base64.b64encode(buffer).decode()

                # Actualizar visualización
                js_update = f"""
                    var canvas = document.querySelector("#canvas");
                    var ctx = canvas.getContext('2d');
                    var img = new Image();
                    img.onload = function() {{
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    }};
                    img.src = 'data:image/jpeg;base64,{img_base64}';
                    document.querySelector("#result").innerHTML = '{label}';
                """
                eval_js(js_update)

            except Exception as e:
                print(f"Error en predicción: {str(e)}")
                continue

        except Exception as e:
            print(f"Error en procesamiento: {str(e)}")
            continue

        time.sleep(0.1)

def main():
    """Función principal"""
    print("Cargando modelo...")
    model = load_model(MODEL_PATH)
    if model is None:
        return

    print("Modelo cargado. Iniciando detección...")
    detect_vehicles(model)

if __name__ == "__main__":
    main()